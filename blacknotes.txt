plan
    build data model

    1. Storage

        all absolute offsets are Long, 8 bytes when fixed
        all magic are Long 8 bytes
        salt is also 8 byte

        // file structure:
        // chunk chunk chunk where each is:
        // d -> data...
        // h -> SDataBase
        // FixedHeader
        //      h : offset 8b
        //      d : offset 8b
        //      fileFormatMagic: 8b

        // Enum constants
        // StorageMagic
        // * StorageMagicCurrentlyWriting
        // * ShreddedMagic

        SKey
            passSalt: Long?
            passIters: Long?
            passHash: Long?
            bytes: ByteArray?

        SDatabase
            keys: ArrayList<SKey>
            root: SRef
            * timestamps: STimeStamps
        
        SRef
            offset: Long
            salt: Long <fixed>
            keyId: Long?

        // SEncryptedChunkHeader
        //    size: Long 8 bytes
        //    crc32: Int
        // not really a structure, 12 bytes read from decrypted 1st block

        // encrypted chunk is read via
        SNode
            * uuid: ByteArray -- each item has uuid
            folder: SFolder?
            note: SNote?
            * file: SFile?

        SFolder
            name: String
            items: ArrayList<SRef>

        SNote
            title: String

        * SFile
            name: String
            body: ByteArray

    2. Model

        MKey
            secretKey: Skey

        MNode is either:
            MNodeFolder
            MNodeNote
            MNodeFile

        MNodeLoading
            ref: Ref

        MNodeFolder

        MNodeNote

        MDatabase
            sdatabase: SDatabase?
            activeKeys: Map<KeyId, SecretKey>
            root: MNode
            * timestamps: MTimestamps
            * settings: MSettings

        NodeId
            offset: Long

        NBase is either
 
 globals:

        все типы данных содержатся в таблице
        singleton, created compile time
            * check on app start (check compile time)
        HashMap<uuid, DataType>
            DataType
                uuid
                load(uuid, LoadingContext)
                    LoadingContext
                        can read primitives maybe

        loadQueue: sorted list of items
            on state update: mark dirty, upon load next reorder
            ability to remove item

        ObjectId = UUID
        KeyId = Int // key hash or something

        NodeHolder
            objectId: ObjectId
            data: NBase 
            keyId: KeyId
            - loading via weak ref -

        NStub ->
            error: String?
            startTime: TimeStamp?
            
            isSleeping()
            isLoading()
            isError()

        NFolder
            name: String
            items: List<NodeHolder>

        NNote
            style: String
            title: String 
            comment: String 

        NFile
            style: String
            name: String
            blob: DBlob

data:
    Nodes N-Classes, live in tree
    NBase
        addr: DAddr
        size: Int

    NFolder
        name: DText?
        style: String
        data: List<NBase>?

    NNote
        title: String
        style: String
        date: DDate
        
    NFile
        name: String
        data: ByteArray
        extra: Attrs

    NStyle
        colorBg: DColor
        colorFg: DColor
        colorRg: DColor
    
    > all data fields with variable size should be like streams
    DBlob = ByteArray
    DColor = String
            
  ! NNoteList - no list of notes - use folder
  ! NCard - card with fields, with customizable sets of fields

    Data, D-Classes, for attributes
    
    R - runtime data, only used in unpacked form
    RDataAddress
        storage: RDataSection
        offset: Int
        size: Int
    
    RDataSection
        storage: RDataStorage
        offset: Int
        
    RDataStorage:
        uuid: UUID
        file: File

    NKeys:
        map name (key digest) -> unpacked key-values

    RKey:

misc
    autochange folder icon to list of notes
    notes filter
    tag filter
    enumerate inner classes, run test for each of them
        - use swith sealed class to test each subclass is present
    enumerate enum members to check they don't collide
    x read packed element from byte array not protobuf full class

    what is protobuf strategy
    uuid stuff
        UUID uuid = UUID.randomUUID();
        byte[] uuidBytes = new byte[16];
        ByteBuffer.wrap(uuidBytes)
        .order(ByteOrder.BIG_ENDIAN)
        .putLong(uuid.getMostSignificantBits())
        .putLong(uuid.getLeastSignificantBits());

Иерархические заметки с мастер паролями.

Суть: заметки, которые легко упорядочить, разделить на делянки под разными паролями и синхронизировать на гугл драйв.

Фичи:
- Иерархия, как папки в файловой системе, не теги, как сейчас везде делают
- Тип текст: просто короткий текст
- Тип аттач: прикреплённый бинарный файл, картинка, pdf и т.п.
- Каждую "папку" можно зашифровать
- Пароли не отдельные на каждую заметку, а набор мастер паролей, допустим один пароль для работы, один для дома

Зачем:
- замена быстрих заметок, но иерархическая (удобнее тегов имхо, хотя теги тоже можно добавить)
- замена парольницы. Для тех у кого 300 разных паролей пинов и т.п.

